if(jointGeneral & length(init.Theta)!=3){
stop("init.Theta must have length 3 when jointGeneral = T.\n
Order should be: c(frailtyVarianceTerminal1,  frailtyVarianceTerminal2, frailtyCorrelation)")
}else if(!jointGeneral & length(init.Theta)!=1){
stop("init.Theta must have length 1 when jointGeneral = F.")
}
if(length(init.B) != nvar){
stop("init.B must be the same length as the number of coefficients.")
}
# If initialization indicated, replace values
if(initialize){
# ignore user-supplied initialization values if initialize == T
init.hazard <- init.hazard*0 + 1
init.B <- init.B*0
# recreate time variable in original data set in case of gap times, create new formula
if(gapTimes){
data$gapTimes <- tt11
initialization.formula <-
paste("Surv(gapTimes, ", EVENT1, ")",
paste(gsub("Surv(.*)","", as.character(formula)), collapse = ""),
collapse = "")
}else{
initialization.formula <- formula
}
initialization.formula <- formula(initialization.formula)
# create separate formulas for each initialization model
initialization.formula1 <- drop.terms(terms(initialization.formula),
survival::untangle.specials(terms(initialization.formula, c("terminal2")), "terminal2", 1:10)$terms,
keep.response = T)
initialization.formula1 <- formula(initialization.formula1)
initialization.formula2 <- drop.terms(terms(initialization.formula),
survival::untangle.specials(terms(initialization.formula, c("terminal")), "terminal", 1:10)$terms,
keep.response = T)
initialization.formula2 <- formula(initialization.formula2)
initialization.formula2 <- sub("terminal2\\(","terminal\\(",initialization.formula2)
initialization.formula2 <- formula(paste0(initialization.formula2[2:3], collapse = "~"))
# fit two joint models for initialization
mod.joint1<-
frailtyPenal(formula = initialization.formula1,
# this line drops the "terminal2" term from the original model formula
formula.terminalEvent = formula.terminalEvent,
jointGeneral = F,
data = data,
recurrentAG= !gapTimes,
hazard = "Weibull",RandDist = "LogN",
maxit = 100, print.times = F)
mod.joint2<-
frailtyPenal(formula = initialization.formula2,
# this line drops the "terminal" term from the original model formula
formula.terminalEvent = formula.terminalEvent2,
jointGeneral = F,
data = data,
recurrentAG= !gapTimes,
hazard = "Weibull", RandDist = "LogN",
maxit = 100, print.times = F)
# Grab initialized values
# Note: Joint model optimizes on the square root scale
# for hazard parameters and frailty
# variance, so we have to square to get to the true scale.
# Recurrent
init.hazard[1:(2+n.knots)] <- (mod.joint1$b[1:(2+n.knots)]^2 + mod.joint2$b[1:(2+n.knots)]^2)/2
# average estimates from the two models
# Terminal 1
init.hazard[(3+n.knots):(4+n.knots*2)] <- mod.joint1$b[(3+n.knots):(4+n.knots*2)]^2
# Terminal 2
init.hazard[(5+n.knots*2):(6+n.knots*3)] <- mod.joint2$b[(3+n.knots):(4+n.knots*2)]^2
# Random Effect Variance
if(!jointGeneral){
init.Theta <- (mod.joint1$b[5+n.knots*2]^2 + mod.joint2$b[5+n.knots*2]^2)/2
# average estimates from the two models
}else{
init.Theta[1] <- mod.joint1$b[5+n.knots*2]^2
init.Theta[2] <- mod.joint2$b[5+n.knots*2]^2
init.Theta[3] <- 0 # rho, covariance
}
# Alpha
init.Alpha1 <- mod.joint1$b[6+n.knots*2]
init.Alpha2 <- mod.joint2$b[6+n.knots*2]
# Coefficients
if(noVarEvent[1] == 0){
# average two estimates
init.B[1:nbvar[1]] <- (mod.joint1$b[(7+n.knots*2):(6+n.knots*2+nbvar[1])] + mod.joint2$b[(7+n.knots*2):(6+n.knots*2+nbvar[1])])/2
}
if(noVarEvent[2] == 0){
init.B[(1+nbvar[1]):(nbvar[1]+nbvar[2])] <- mod.joint1$b[(7+n.knots*2+nbvar[1]):(6+n.knots*2+nbvar[1]+nbvar[2])]
}
if(noVarEvent[4] == 0){
init.B[(1+nbvar[1]+nbvar[2]):(nbvar[1]+nbvar[2]+nbvar[4])] <- mod.joint2$b[(7+n.knots*2+nbvar[1]):(6+n.knots*2+nbvar[1]+nbvar[4])]
}
}
# Fill parameter vector
if(!jointGeneral){
b <- c(log(sqrt(init.hazard)),
log(sqrt(init.Theta)),
init.Alpha1, init.Alpha2,
init.B)
}else{
b <- c(log(sqrt(init.hazard)),
log(sqrt(init.Theta[1:2])), # variance
log((init.Theta[3]+1)/(1-init.Theta[3])), # rho transformed using scale-logit
init.Alpha1, init.Alpha2,
init.B)
}
start.b <- b
if(length(b)!=np) stop("Parameter vector not the correct length.")
cat("\nmultivPenal.R:: length(b)=",length(b),
"\nmultivPenal.R:: np = ",np,
file='../package_tests/multiv_model_progress.dat',append=TRUE)
###################################################
# Check Dimensions of all variables for debugging
controls = c(maxit = maxit[1], # [1]
initialize = initialize, # [2]
typeof = typeof, # [3]
equidistant = 1, # [4]
irep = !crossVal, # [5] irep
gapTimes = gapTimes, # [6] ag0
nbIntervEvent = 0, # [7] nbIntervEvent
n.knots = n.knots, # [8]
event2.ind = event2.ind, # [9]
terminal2.ind = terminal2.ind, # [10]
GHpoints = GHpoints, # [11]
jointGeneral = as.integer(jointGeneral)) # [12] typeJoint0
if(length(controls) != 12) stop("Length of 'controls' not 12.")
cat("\nmultivPenal.R:: length(controls)=",length(controls),
file='../package_tests/multiv_model_progress.dat',append=TRUE)
nobsEvent = c(length(event1),
length(terminal1),
length(event2))
if(length(nobsEvent)!= 3) stop("Length of 'nobsEvent' not 3.")
cat("\n\nmultivPenal.R::nobsEvent=", nobsEvent,
file='../package_tests/multiv_model_progress.dat',append=TRUE)
if(length(kappa) != 4) stop("Length of 'kappa' not 4.")
cat("\nkappa=", kappa,file='../package_tests/multiv_model_progress.dat',append=TRUE)
### Recurrent 1
if(length(tt10) != nobsEvent[1] | length(tt10) !=  nobsEvent[1] | length(event1) !=  nobsEvent[1] | length(group1) !=  nobsEvent[1]){
stop("Length of tt00, tt10, event1, group1 not nobsEvent[1]")
}
cat("\nmultivPenal.R:: length(tt10)=",length(tt10),
"\nmultivPenal.R:: length(tt11)=",length(tt11),
"\nmultivPenal.R:: length(event1)=",length(event1),
"\nmultivPenal.R:: length(group1)=",length(group1),
"\nmultivPenal.R:: max(group1)=",max(group1),
"\nmultivPenal.R:: length(unique(group1))=",length(unique(group1)),
file='../package_tests/multiv_model_progress.dat',append=TRUE)
### Recurrent 2
if(length(tt0meta0) !=  nobsEvent[3]  | length(tt1meta0) !=  nobsEvent[3]  | length(group2) !=  nobsEvent[3]  | length(event2) !=  nobsEvent[3] ){
stop("Length of tt0meta0, tt1meta0, group2, event2 not nobsEvent[3]")
}
cat("\nmultivPenal.R:: length(tt0meta0)=",length(tt0meta0),
"\nmultivPenal.R:: length(tt1meta0)=",length(tt1meta0),
"\nmultivPenal.R:: length(group2)=",length(group2),
"\nmultivPenal.R:: length(event2)=",length(event2),
"\nmultivPenal.R:: max(group2)=",max(group2),
"\nmultivPenal.R:: length(unique(group2))=",length(unique(group2)),
file='../package_tests/multiv_model_progress.dat',append=TRUE)
if(length(event1) != nobsEvent[1]) stop("length(event1) != nobsEvent[1]")
if(length(event2) != nobsEvent[3]) stop("length(event2) != nobsEvent[3]")
if(length(group1) != nobsEvent[1]) stop("length(group1) != nobsEvent[1]")
if(length(group2) != nobsEvent[3]) stop("length(group2) != nobsEvent[3]")
if(length(groupdc) != nobsEvent[2]) stop("length(groupdc) != nobsEvent[2]")
if(max(group1) != nobsEvent[2]) stop("max(group1) != nobsEvent[2]")
if(max(groupdc) != nobsEvent[2]) stop("max(groupdc) != nobsEvent[2]")
if(length(tt1dc) != nobsEvent[2]) stop("length(tt1dc) != nobsEvent[2]")
### Terminal Events
if(length(terminal1) != nobsEvent[2]){
cat("nobsEvent[2] = ", nobsEvent[2], " and length(terminal1) = ",length(terminal1))
stop("length(terminal1) != nobsEvent[2]")
}
if(length(terminal2) != nobsEvent[2]){
cat("nobsEvent[2] = ", nobsEvent[2], " and length(terminal2) = ",length(terminal2))
stop("length(terminal2) != nobsEvent[2]")
}
cat("\nmultivPenal.R:: length(terminal1, terminal2, groupdc, tt1dc)=",
length(terminal1),length(terminal2),length(groupdc),length(tt1dc),
file='../package_tests/multiv_model_progress.dat',append=TRUE)
if(length(nbvar) != 4) stop("length(nbvar) != 4")
cat("\nmultivPenal.R:: nbvar=",nbvar,
file='../package_tests/multiv_model_progress.dat',append=TRUE)
if(all(dim(modelmatrix1) != c(nobsEvent[1],nbvar[1]))) stop("all(dim(modelmatrix1) != c(nobsEvent[1],nbvar[1]))")
if(all(dim(modelmatrix2) != c(nobsEvent[2],nbvar[2]))) stop("all(dim(modelmatrix2) != c(nobsEvent[3],nbvar[2]))")
if(all(dim(modelmatrix3) != c(nobsEvent[3],nbvar[3]))) stop("all(dim(modelmatrix3) != c(nobsEvent[2],nbvar[3]))")
if(all(dim(modelmatrix4) != c(nobsEvent[2],nbvar[4]))) stop("all(dim(modelmatrix4) != c(nobsEvent[3],nbvar[4]))")
cat("\nmultivPenal.R:: dim(modelmatrix1, modelmatrix2, modelmatrix3, modelmatrix4)",
dim(modelmatrix1),",", dim(modelmatrix2),",", dim(modelmatrix3),",", dim(modelmatrix4),
file='../package_tests/multiv_model_progress.dat',append=TRUE)
if(length(noVarEvent) != 4) stop("length(noVarEvent) != 4")
cat("\nmultivPenal.R:: noVarEvent=",noVarEvent,
file='../package_tests/multiv_model_progress.dat',append=TRUE)
if(any(is.na(modelmatrix1))|any(is.na(modelmatrix2))|any(is.na(modelmatrix3))|any(is.na(modelmatrix4))){
stop("NA values among covariates. Reconfigure Data.")
}
######################################################################################################
# Send to Fortran for optimization
ans <- .Fortran(C_joint_multiv,
controls = as.integer(controls),
nobsEvent = as.integer(nobsEvent), #nobsEvent
k0 = as.double(kappa),
# Data Arguments
tt00 = as.double(tt10),
tt10 = as.double(tt11),
tt0meta0 = as.double(tt0meta0),
tt1meta0 = as.double(tt1meta0),
ic0 = as.integer(event1), #ic0
icmeta0 = as.integer(event2), #icmeta0
groupe0 = as.integer(group1),#groupe0
groupe0meta = as.integer(group2),#groupe0meta
groupe0dc = as.integer(groupdc),#groupe0dc
tt0dc0 = as.double(0*tt1dc), #tt0dc0
tt1dc0 = as.double(tt1dc), #tt1dc0
icdc0 = as.integer(terminal1), #icdc0
icdc20 = as.integer(terminal2), #icdc20
nbvar = as.integer(nbvar), #nbvar
vax0 = as.double(modelmatrix1),
vaxdc0 = as.double(modelmatrix2), #vaxdc0
vaxmeta0 = as.double(modelmatrix3),
vaxdc20 = as.double(modelmatrix4), #vaxdc20
noVarEvent = as.integer(noVarEvent), #noVarEvent
# Parameter Information
np=as.integer(np),
b=as.double(b),
H_hessOut=as.double(matrix(0,nrow=np,ncol=np)),
HIHOut=as.double(matrix(0,nrow=np,ncol=np)),
resOut=as.double(0),
LCV=as.double(rep(0,2)),
critCV=as.integer(rep(0,6)),
mtEvent = as.integer(rep(100,4)), #mtEvent
mt1Event = as.integer(rep(100,4)), #mt1Event
# Survival and Hazard Function Fits
x1=as.double(rep(0,100)),                  #x1Out
lam=as.double(matrix(0,nrow=100,ncol=3)),  #lamOut
xSu1=as.double(rep(0,100)),                #xSu1
surv=as.double(matrix(0,nrow=100,ncol=3)), #suOut
x2=as.double(rep(0,100)),                  #x2Out
lam2=as.double(matrix(0,nrow=100,ncol=3)), #lam2Out
xSu2=as.double(rep(0,100)),                #xSu2
surv2=as.double(matrix(0,nrow=100,ncol=3)),#su2Out
x3=as.double(rep(0,100)),                  #x3Out
lam3=as.double(matrix(0,nrow=100,ncol=3)), #lam3out
xSu3=as.double(rep(0,100)),                #xSu3
surv3=as.double(matrix(0,nrow=100,ncol=3)),#su3Out
x4=as.double(rep(0,100)),                  #x4Out
lam4=as.double(matrix(0,nrow=100,ncol=3)), #lam4Out
xSu4=as.double(rep(0,100)),                #xSu4
surv4=as.double(matrix(0,nrow=100,ncol=3)),#su4Out
ni=as.integer(0),
cptEvent=as.integer(rep(0,4)),
ResMartingaleEvent=as.double(matrix(0,nrow=nobsEvent[2],ncol=3)),
frailtyEstimates=as.double(matrix(0,nrow=nobsEvent[2],ncol=5)),
linearpred=as.double(rep(0,nobsEvent[1])),
linearpreddc=as.double(rep(0,nobsEvent[2])),
linearpredM=as.double(rep(0,nobsEvent[3])),
linearpreddc2=as.double(rep(0,nobsEvent[2])),
ziOut1=as.double(rep(0,controls[8]+6)),
ziOutdc=as.double(rep(0,controls[8]+6)),
ziOutmeta=as.double(rep(0,controls[8]+6)),
time=as.double(rep(0,controls[7]+1)),
timedc=as.double(rep(0,controls[7]+1)),
timeM=as.double(rep(0,controls[7]+1)),
ghNodes = as.double(ghNodes),
ghWeights = as.double(ghWeights)
)
######################################################################################################
# Send to Fortran for optimization
ans <- .Fortran(frailtypack:::C_joint_multiv,
controls = as.integer(controls),
nobsEvent = as.integer(nobsEvent), #nobsEvent
k0 = as.double(kappa),
# Data Arguments
tt00 = as.double(tt10),
tt10 = as.double(tt11),
tt0meta0 = as.double(tt0meta0),
tt1meta0 = as.double(tt1meta0),
ic0 = as.integer(event1), #ic0
icmeta0 = as.integer(event2), #icmeta0
groupe0 = as.integer(group1),#groupe0
groupe0meta = as.integer(group2),#groupe0meta
groupe0dc = as.integer(groupdc),#groupe0dc
tt0dc0 = as.double(0*tt1dc), #tt0dc0
tt1dc0 = as.double(tt1dc), #tt1dc0
icdc0 = as.integer(terminal1), #icdc0
icdc20 = as.integer(terminal2), #icdc20
nbvar = as.integer(nbvar), #nbvar
vax0 = as.double(modelmatrix1),
vaxdc0 = as.double(modelmatrix2), #vaxdc0
vaxmeta0 = as.double(modelmatrix3),
vaxdc20 = as.double(modelmatrix4), #vaxdc20
noVarEvent = as.integer(noVarEvent), #noVarEvent
# Parameter Information
np=as.integer(np),
b=as.double(b),
H_hessOut=as.double(matrix(0,nrow=np,ncol=np)),
HIHOut=as.double(matrix(0,nrow=np,ncol=np)),
resOut=as.double(0),
LCV=as.double(rep(0,2)),
critCV=as.integer(rep(0,6)),
mtEvent = as.integer(rep(100,4)), #mtEvent
mt1Event = as.integer(rep(100,4)), #mt1Event
# Survival and Hazard Function Fits
x1=as.double(rep(0,100)),                  #x1Out
lam=as.double(matrix(0,nrow=100,ncol=3)),  #lamOut
xSu1=as.double(rep(0,100)),                #xSu1
surv=as.double(matrix(0,nrow=100,ncol=3)), #suOut
x2=as.double(rep(0,100)),                  #x2Out
lam2=as.double(matrix(0,nrow=100,ncol=3)), #lam2Out
xSu2=as.double(rep(0,100)),                #xSu2
surv2=as.double(matrix(0,nrow=100,ncol=3)),#su2Out
x3=as.double(rep(0,100)),                  #x3Out
lam3=as.double(matrix(0,nrow=100,ncol=3)), #lam3out
xSu3=as.double(rep(0,100)),                #xSu3
surv3=as.double(matrix(0,nrow=100,ncol=3)),#su3Out
x4=as.double(rep(0,100)),                  #x4Out
lam4=as.double(matrix(0,nrow=100,ncol=3)), #lam4Out
xSu4=as.double(rep(0,100)),                #xSu4
surv4=as.double(matrix(0,nrow=100,ncol=3)),#su4Out
ni=as.integer(0),
cptEvent=as.integer(rep(0,4)),
ResMartingaleEvent=as.double(matrix(0,nrow=nobsEvent[2],ncol=3)),
frailtyEstimates=as.double(matrix(0,nrow=nobsEvent[2],ncol=5)),
linearpred=as.double(rep(0,nobsEvent[1])),
linearpreddc=as.double(rep(0,nobsEvent[2])),
linearpredM=as.double(rep(0,nobsEvent[3])),
linearpreddc2=as.double(rep(0,nobsEvent[2])),
ziOut1=as.double(rep(0,controls[8]+6)),
ziOutdc=as.double(rep(0,controls[8]+6)),
ziOutmeta=as.double(rep(0,controls[8]+6)),
time=as.double(rep(0,controls[7]+1)),
timedc=as.double(rep(0,controls[7]+1)),
timeM=as.double(rep(0,controls[7]+1)),
ghNodes = as.double(ghNodes),
ghWeights = as.double(ghWeights)
)
ans
ans$critCV
######################################################################################################
# Format Model Tables
if(jointGeneral == F & hazard == "Weibull"){
f <- function(b){
c(exp(b[1:6])^2,
exp(b[7]),
b[(np-nvar-1):np])
}
f.prime <- function(b){
diag(c(2*exp(2*b[1:6]),
exp(b[7]),
rep(1,nvar + 2)))
}
Parameter = c("Shape, Recurrent", "Scale, Recurrent",
"Shape, Terminal1", "Scale, Terminal1",
"Shape, Terminal2", "Scale, Terminal2",
"Sigma",
"Alpha, Terminal1", "Alpha, Terminal2",
paste0("Beta",(np-nvar+1):np))
}else if(jointGeneral == T & hazard == "Weibull"){
f <- function(b){
c(exp(b[1:6])^2,
exp(b[7:8]),
(exp(b[9]) - 1)/(exp(b[9]) + 1),
b[(np-nvar-1):np])
}
f.prime <- function(b){
diag(c(2*exp(2*b[1:6]),
exp(b[7:8]),
2*exp(2*b[9])/(1+exp(b[9]))^2,
rep(1,nvar+2)))
}
Parameter = c("Shape, Recurrent", "Scale, Recurrent",
"Shape, Terminal1", "Scale, Terminal1",
"Shape, Terminal2", "Scale, Terminal2",
"Sigma, Terminal1", "Sigma, Terminal2", "Rho",
"Alpha, Terminal1", "Alpha, Terminal2",
paste0("Beta",(np-nvar+1):np))
}else if(jointGeneral == F & hazard == "Weibull"){
f <- function(b){
c(exp(b[1:6])^2,
exp(b[7]),
b[(np-nvar-1):np])
}
f.prime <- function(b){
diag(c(2*exp(2*b[1:6]),
exp(b[7]),
rep(1,nvar + 2)))
}
Parameter = c("Shape, Recurrent", "Scale, Recurrent",
"Shape, Terminal1", "Scale, Terminal1",
"Shape, Terminal2", "Scale, Terminal2",
"Sigma",
"Alpha, Terminal1", "Alpha, Terminal2",
paste0("Beta",(np-nvar+1):np))
}else if(jointGeneral == T & hazard == "Splines"){
f <- function(b){
c(exp(b[1:6])^2,
exp(b[7:8]),
(exp(b[9]) - 1)/(exp(b[9]) + 1),
b[(np-nvar-1):np])
}
f.prime <- function(b){
diag(c(2*exp(2*b[1:6]),
exp(b[7:8]),
2*exp(2*b[9])/(1+exp(b[9]))^2,
rep(1,nvar+2)))
}
Parameter = c("Shape, Recurrent", "Scale, Recurrent",
"Shape, Terminal1", "Scale, Terminal1",
"Shape, Terminal2", "Scale, Terminal2",
"Sigma, Terminal1", "Sigma, Terminal2", "Rho",
"Alpha, Terminal1", "Alpha, Terminal2",
paste0("Beta",(np-nvar+1):np))
}
ans$varH.Raw <- matrix(ans$H, nrow = np, ncol = np)
ans$H
ans$HIHOut
ans$varH.Raw <- matrix(ans$H, nrow = np, ncol = np)
ans$varH.Raw <- matrix(ans$HIHOut, nrow = np, ncol = np)
ans$varH.Raw <- matrix(ans$H_hessOut, nrow = np, ncol = np)
ans$HIHOut
ans$H_hessOut
library(frailtypack)
knitr::opts_chunk$set(echo = TRUE, warning = FALSE, message = FALSE)
library(frailtypack); library(tidyverse)
source("../delirium_package/R/competing_simulate_data.R")
source("../delirium_package/R/random_weibull.R")
source("../delirium_package/R/extract_frailtypack_coef_weibullgap.R")
mod0 <-
multivPenal(
formula = Surv(t0, t, event)~cluster(id)+trt+terminal(terminal1)+terminal2(terminal2),
formula.terminalEvent=~trt,
formula.terminalEvent2=~trt,
data=data,
jointGeneral = F,
initialize = T,
save.progress = T,
hazard = "Weibull",
gapTimes=T,
maxit = 350)
library(frailtypack)
knitr::opts_chunk$set(echo = TRUE, warning = FALSE, message = FALSE)
library(frailtypack); library(tidyverse)
source("../delirium_package/R/competing_simulate_data.R")
source("../delirium_package/R/random_weibull.R")
source("../delirium_package/R/extract_frailtypack_coef_weibullgap.R")
mod0 <-
multivPenal(
formula = Surv(t0, t, event)~cluster(id)+trt+terminal(terminal1)+terminal2(terminal2),
formula.terminalEvent=~trt,
formula.terminalEvent2=~trt,
data=data,
jointGeneral = F,
initialize = T,
save.progress = T,
hazard = "Weibull",
gapTimes=T,
maxit = 350)
mod0
mod0$summary.table
library(frailtypack)
library(frailtypack)
library(frailtypack); library(tidyverse)
knitr::opts_chunk$set(echo = TRUE, warning = FALSE, message = FALSE)
library(frailtypack); library(tidyverse)
source("../delirium_package/R/competing_simulate_data.R")
source("../delirium_package/R/random_weibull.R")
source("../delirium_package/R/extract_frailtypack_coef_weibullgap.R")
par00 = c(betaR = 1, etaR = 10,
betaD = 1.85, etaD = 25,
betaD2 = 1.15, etaD2 = 10,
theta = 0.2, alpha1 = -0.12, alpha2 = -0.32,
trtR = -0.08, trtD = 0.07, trtD2 = 0.08)
paste(par, collapse="_")
paste(par00, collapse="_")
par = par00
source("competing_simulate_data.R")
# (1) Simulate Data Set
data <- simulate.competing.data(n = n, truncate = 28, par0 = par)
source("../delirium_package/R/competing_simulate_data.R")
source("../delirium_package/R/random_weibull.R")
source("../delirium_package/R/extract_frailtypack_coef_weibullgap.R")
# (1) Simulate Data Set
data <- simulate.competing.data(n = n, truncate = 28, par0 = par)
n = 1500
# (1) Simulate Data Set
data <- simulate.competing.data(n = n, truncate = 28, par0 = par)
data
# (2) Fit Model
mod <-
multivPenal(
formula = Surv(t0, t, event)~cluster(id)+trt+terminal(terminal1)+terminal2(terminal2),
formula.terminalEvent=~trt,
formula.terminalEvent2=~trt,
data=data,
jointGeneral = F,
initialize = T,
save.progress = T,
hazard = "Weibull",
gapTimes=T,
maxit = 350)
# (2) Fit Model
mod <-
multivPenal(formula = Surv(t0, t, event)~cluster(id)+trt+terminal(terminal1)+terminal2(terminal2),
formula.terminalEvent=~trt,
formula.terminalEvent2=~trt,
data=data,
jointGeneral = F,
initialize = T,
save.progress = T,
hazard = "Weibull",
gapTimes=T,
maxit = 350)
mod$critCV
mod$initialization$joint1$istop
# Add identifiers to model object for further analysis
mod$simulation.values <- par
mod$simulation.id <- id
