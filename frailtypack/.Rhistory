initialize = T
n.knots <- 0 # remove when splines models are available
if (class(formula) != "formula")
stop("The argument formula must be a formula")
if (nrow(data) == 0)
stop("No (non-missing) observations")
############################ Verify Event 1 / Times
# NN =  names of time gap and recurrent event 1
Y1 <- get_all_vars(update(formula, "~1"), data)
if (ncol(Y1) != 3) {
stop(
"Survival object outcome must be specified using \n
time when at risk period starts and stops, such as: \n
Surv(time.start, time.stop, event.indicator).
This is true for both calendar time and gap time
formulations."
)
}
NN <- colnames(Y1)
EVENT1 <- NN[3]
TSTART <- NN[1]
TSTOP <- NN[2]
event1 <- Y1[, 3]
tt10 <- Y1[, 1]
tt11 <- Y1[, 2]
############################ Verify recurrent event 2 (Not yet implemented)
event2.ind <- 0
############################ Verify Terminal Event 1
TT <-
survival::untangle.specials(terms(formula, c("terminal")), "terminal", 1:10)$vars
start <- grep("\\(", unlist(strsplit(TT, "")))
stop <- grep("\\)", unlist(strsplit(TT, "")))
TERMINAL1 <- substr(TT, start = start + 1, stop = stop - 1)
if (length(TERMINAL1) == 0) {
stop("A term for a terminal event must be included in the formula.")
}
if (!all(data[[TERMINAL1]] %in% c(1, 0))) {
stop("terminal must contain a variable coded 0-1 and a non-factor variable")
}
############################ Verify Terminal Event 2
TT <-survival::untangle.specials(terms(formula, c("terminal2")), "terminal2", 1:10)$vars
start <- grep("\\(", unlist(strsplit(TT, "")))
stop <- grep("\\)", unlist(strsplit(TT, "")))
TERMINAL2 <- substr(TT, start = start + 1, stop = stop - 1)
if (length(TERMINAL2) == 0) {
terminal2.ind <- 0
} else{
if (!all(data[[TERMINAL2]] %in% c(1, 0))) {
stop(
"terminal must contain a variable coded 0-1 and a non-factor variable"
)
}
terminal2.ind <- 1
}
################################ Verify Cluster Variable
# name of cluster variable
TT <-
survival::untangle.specials(terms(formula, c("cluster")), "cluster", 1:10)$vars
start <- grep("\\(", unlist(strsplit(TT, "")))
stop <- grep("\\)", unlist(strsplit(TT, "")))
CLUSTER <- substr(TT, start = start + 1, stop = stop - 1)
if (length(data[[CLUSTER]])) {
uni.cluster <- unique(data[[CLUSTER]])
} else{
stop("grouping variable is needed")
}
if (length(uni.cluster) == 1) {
stop("grouping variable must have more than 1 level")
}
if (event2.ind == 1){
if(CLUSTER %in% colnames(data.Event2)) {
stop("grouping variable must be present in data.Event2")
}
if (!all(uni.cluster %in% data.Event2[[CLUSTER]])) {
stop("all groups must be represented in data.Event2")
}
}
if (hazard != "Weibull") {
stop("Only 'Weibull' has been implemented in competing joint model.")
}
haztemp <- hazard
# typeof is the numerical indicator for hazard
typeof <- switch(hazard,
"Splines" = 0,
"Weibull" = 2)
# Specify whether spline points are regularly spaced or at percentiles
if(typeof == 0) {
equidistant <- 1
}else if(typeof == 2){
### Weibull
equidistant <- 1
}
# noVarEvent indicates whether there are no explanatory variables for the
# recurrent1, terminal1, recurrent2, and terminal2 events (in that order)
noVarEvent = c(0,0,1,0)
# delete specials from the formula to get just covariates
# on right side.
specials = c("strata", "cluster", "terminal", "event2", "terminal2")
Terms = terms(formula, specials = specials)
# Check if all terms on right side of Recurrent event formula are specials
if(length(unlist(attr(Terms, "specials"))) == (length(unlist(attr(Terms, "variables")))-2)){
noVarEvent[1] <- 1
}
# Check for terminal1 formula
if(is.null(formula.terminalEvent)){
noVarEvent[2] <- 1
}
# Check for terminal2 formula
if(is.null(formula.terminalEvent2)){
noVarEvent[4] <- 1
}
# Recurrent Event 1 Model Matrix
if(noVarEvent[1] == 0){
modelmatrix1 =
model.matrix(update(
drop.terms(
termobj = terms(formula),
unlist(attr(Terms, "specials")) - 1,
keep.response = TRUE
),
~ . - 1
),
data)
}else{
modelmatrix1 = matrix(0)
}
# need to get densely-ranked ids
group1 <- as.numeric(factor(data[[CLUSTER]]))
# Recurrent Event 2 Model Matrix
if (event2.ind == 1) {
group2 <- as.numeric(factor(data.Event2[[CLUSTER]]))
# Compute Event Counts
#nevents2 <- tapply(event2, group2, sum)
Terms2 = terms(formula.Event2, specials = specials)
if (!is.null(unlist(attr(Terms2, "specials")))) {
modelmatrix3 =
model.matrix(update(
drop.terms(
termobj = terms(formula.Event2),
unlist(attr(
Terms2, "specials"
)) - 1,
keep.response = TRUE
),
~ . - 1
),
data.Event2)
} else{
modelmatrix3 =
model.matrix(update(formula.Event2, ~ . - 1),
data.Event2)
}
} else{
modelmatrix3 = matrix(0)
group2 = 0
}
# Terminal Event 1 Model Matrix
data.terminal <- do.call(what = "rbind",
lapply(split(x = data, f = data[[CLUSTER]]),
function(df) {
subset(df, df[[TSTOP]] == max(df[[TSTOP]]))
}))
groupdc <- as.numeric(factor(data.terminal[[CLUSTER]]))
tt1dc <- data.terminal[[TSTOP]]
terminal1 <- data.terminal[[TERMINAL1]]
if(noVarEvent[2]==0){
modelmatrix2 = model.matrix(update(formula.terminalEvent, ~ . - 1), data.terminal)
}
# Terminal 2 Model Matrix
if((terminal2.ind == 1)) {
if(noVarEvent[4] == 0){
modelmatrix4 = model.matrix(update(formula.terminalEvent2, ~ . - 1),
data.terminal)
}else{
modelmatrix4 = matrix(0)
}
terminal2 <- data.terminal[[TERMINAL2]]
} else{
terminal2 <- data.terminal[[TERMINAL1]]*0
modelmatrix4 = matrix(0)
}
### Total number of parameters
nvar = ncol(modelmatrix1) * (1-noVarEvent[1]) +
ncol(modelmatrix2) * (1-noVarEvent[2])  +
ncol(modelmatrix3) * event2.ind * (1-noVarEvent[3])+
ncol(modelmatrix4) * terminal2.ind * (1-noVarEvent[4])
nbvar = c(
ncol(modelmatrix1),
ncol(modelmatrix2),
ncol(modelmatrix3),
ncol(modelmatrix4)
)
# Total number of parameters
# This will need adjustment before incorporating a second recurrent event
if(typeof==0 ){ # splines, single random effect
np = ((2 + n.knots) * (2 + event2.ind + terminal2.ind) + nvar + 3 + 2*jointGeneral)
}else if(typeof == 2){ # weibull, single random effect
np = (2 * (2 + event2.ind + terminal2.ind) + nvar + 3 + 2*jointGeneral)
}
gh <- statmod::gauss.quad(GHpoints, kind="hermite")
gh <- statmod::gauss.quad(GHpoints, kind="hermite")
GHpoints = 32
gh <- statmod::gauss.quad(GHpoints, kind="hermite")
ghNodes = gh$nodes
ghWeights = gh$weights * exp(gh$nodes^2)
if(is.null(init.hazard)) init.hazard <- rep(1, np - nvar - 3 - 2*jointGeneral)
init.hazard = NULL
if(is.null(init.hazard)) init.hazard <- rep(1, np - nvar - 3 - 2*jointGeneral)
init.B = NULL
# Check if user entered values for coefficients, input 0s if not
if(is.null(init.B)) init.B <- rep(0, nvar)
# Check lengths of inputs
if(typeof == "Weibull" & length(init.hazard != 2 * (2 + event2.ind + terminal2.ind))){
stop("init.hazard must have length 6 for weibull for three
event types, or length 8 for four event types.")
}else if(typeof == "Splines" & length(init.hazard != (n.knots + 2) * (2 + event2.ind + terminal2.ind))){
stop("init.hazard must have length (n.knots + 2) * number of event types (3 or 4) for splines.")
}
if(jointGeneral & length(init.Sigma)!=3){
stop("init.Sigma must have length 3 when jointGeneral = T.\n
Order should be: c(frailtySDTerminal1,  frailtySDTerminal2, frailtyCorrelation)")
}else if(!jointGeneral & length(init.Sigma)!=1){
stop("init.Sigma must have length 1 when jointGeneral = F.")
}
init.Sigma = 0.5
if(jointGeneral & length(init.Sigma)!=3){
stop("init.Sigma must have length 3 when jointGeneral = T.\n
Order should be: c(frailtySDTerminal1,  frailtySDTerminal2, frailtyCorrelation)")
}else if(!jointGeneral & length(init.Sigma)!=1){
stop("init.Sigma must have length 1 when jointGeneral = F.")
}
if(length(init.B) != nvar){
stop("init.B must be the same length as the number of coefficients.")
}
# If initialization indicated, replace values
if(initialize){
# ignore user-supplied initialization values if initialize == T
init.hazard <- init.hazard*0 + 1
init.B <- init.B*0
# recreate time variable in original data set in case of gap times, create new formula
if(gapTimes){
#data$gapTimes <- tt11
initialization.formula <-
paste("Surv(gapTimes, ", EVENT1, ")",
paste(gsub("Surv(.*)","", as.character(formula)), collapse = ""),
collapse = "")
data$gapTimes <- tt11
initialization.formula <-
paste("Surv(gapTimes, ", EVENT1, ")",
paste(gsub("Surv(.*)","", as.character(formula)), collapse = ""),
collapse = "")
}else{
initialization.formula <- formula
}
#initialization.formula <- formula
# create separate formulas for each initialization model
initialization.formula1 <- drop.terms(terms(initialization.formula),
survival::untangle.specials(terms(initialization.formula, c("terminal2")), "terminal2", 1:10)$terms,
keep.response = T)
initialization.formula1 <- formula(initialization.formula1)
initialization.formula2 <- drop.terms(terms(initialization.formula),
survival::untangle.specials(terms(initialization.formula, c("terminal")), "terminal", 1:10)$terms,
keep.response = T)
initialization.formula2 <- formula(initialization.formula2)
initialization.formula2 <- sub("terminal2\\(","terminal\\(",initialization.formula2)
initialization.formula2 <- formula(paste0(initialization.formula2[2:3], collapse = "~"))
# fit two joint models for initialization
mod.joint1<-
frailtyPenal(formula = initialization.formula1,
# this line drops the "terminal2" term from the original model formula
formula.terminalEvent = formula.terminalEvent,
jointGeneral = F,
data = data,
recurrentAG= !gapTimes,
hazard = "Weibull", RandDist = "LogN",
maxit = 100, print.times = F)
mod.joint2<-
frailtyPenal(formula = initialization.formula2,
# this line drops the "terminal" term from the original model formula
formula.terminalEvent = formula.terminalEvent2,
jointGeneral = F,
data = data,
recurrentAG= !gapTimes,
hazard = "Weibull", RandDist = "LogN",
maxit = 100, print.times = F)
# Grab initialized values
# Note: Joint model optimizes on the square root scale
# for hazard parameters and frailty
# variance, so we have to square to get to the true scale.
# Recurrent Hazard
init.hazard[1:(2+n.knots)] <- (mod.joint1$b[1:(2+n.knots)]^2 + mod.joint2$b[1:(2+n.knots)]^2)/2
# average estimates from the two models
# Terminal 1 Hazard
init.hazard[(3+n.knots):(4+n.knots*2)] <- mod.joint1$b[(3+n.knots):(4+n.knots*2)]^2
# Terminal 2 Hazard
init.hazard[(5+n.knots*2):(6+n.knots*3)] <- mod.joint2$b[(3+n.knots):(4+n.knots*2)]^2
# Random Effect Variance
if(!jointGeneral){
init.Sigma <- (abs(mod.joint1$b[5+n.knots*2]) + abs(mod.joint2$b[5+n.knots*2]))/2
# average estimates from the two models
}else{
init.Sigma[1] <- abs(mod.joint1$b[5+n.knots*2])
init.Sigma[2] <- abs(mod.joint2$b[5+n.knots*2])
init.Sigma[3] <- 0 # rho, covariance
}
# Alpha
init.Alpha1 <- mod.joint1$b[6+n.knots*2]
init.Alpha2 <- mod.joint2$b[6+n.knots*2]
# Coefficients
if(noVarEvent[1] == 0){
# average two estimates
init.B[1:nbvar[1]] <- (mod.joint1$b[(7+n.knots*2):(6+n.knots*2+nbvar[1])] + mod.joint2$b[(7+n.knots*2):(6+n.knots*2+nbvar[1])])/2
}
if(noVarEvent[2] == 0){
init.B[(1+nbvar[1]):(nbvar[1]+nbvar[2])] <- mod.joint1$b[(7+n.knots*2+nbvar[1]):(6+n.knots*2+nbvar[1]+nbvar[2])]
}
if(noVarEvent[4] == 0){
init.B[(1+nbvar[1]+nbvar[2]):(nbvar[1]+nbvar[2]+nbvar[4])] <- mod.joint2$b[(7+n.knots*2+nbvar[1]):(6+n.knots*2+nbvar[1]+nbvar[4])]
}
}
# ignore user-supplied initialization values if initialize == T
init.hazard <- init.hazard*0 + 1
init.B <- init.B*0
# recreate time variable in original data set in case of gap times, create new formula
if(gapTimes){
#data$gapTimes <- tt11
initialization.formula <-
paste("Surv(gapTimes, ", EVENT1, ")",
paste(gsub("Surv(.*)","", as.character(formula)), collapse = ""),
collapse = "")
data$gapTimes <- tt11
initialization.formula <-
paste("Surv(gapTimes, ", EVENT1, ")",
paste(gsub("Surv(.*)","", as.character(formula)), collapse = ""),
collapse = "")
}else{
initialization.formula <- formula
}
# create separate formulas for each initialization model
initialization.formula1 <- drop.terms(terms(initialization.formula),
survival::untangle.specials(terms(initialization.formula, c("terminal2")), "terminal2", 1:10)$terms,
keep.response = T)
initialization.formula
# create separate formulas for each initialization model
initialization.formula <- terms(initialization.formula, specials = specials)
specials
initialization.formula
terms(initialization.formula, specials = specials)
initialization.formula
initialization.formula
terms(initialization.formula, specials = specials)
terms(initialization.formula)
initialization.formula
terms(initialization.formula, c("terminal2"))
gapTimes
initialization.formula
colnames(data)
terms(y ~ x + z)
initialization formula
initialization.formula
initialization.formula <- as.fomula(initialization.formula)
initialization.formula <- fomula(initialization.formula)
initialization.formula <- as.formula(initialization.formula)
initialization.formula
# create separate formulas for each initialization model
initialization.formula <- terms(initialization.formula, specials = specials)
initialization.formula1 <- drop.terms(terms(initialization.formula),
survival::untangle.specials(terms(initialization.formula, c("terminal2")), "terminal2", 1:10)$terms,
keep.response = T)
initialization.formula1 <- formula(initialization.formula1)
initialization.formula2 <- drop.terms(terms(initialization.formula),
survival::untangle.specials(terms(initialization.formula, c("terminal")), "terminal", 1:10)$terms,
keep.response = T)
initialization.formula2 <- formula(initialization.formula2)
initialization.formula2 <- sub("terminal2\\(","terminal\\(",initialization.formula2)
initialization.formula2 <- formula(paste0(initialization.formula2[2:3], collapse = "~"))
# fit two joint models for initialization
mod.joint1<-
frailtyPenal(formula = initialization.formula1,
# this line drops the "terminal2" term from the original model formula
formula.terminalEvent = formula.terminalEvent,
jointGeneral = F,
data = data,
recurrentAG= !gapTimes,
hazard = "Weibull", RandDist = "LogN",
maxit = 100, print.times = F)
mod.joint2<-
frailtyPenal(formula = initialization.formula2,
# this line drops the "terminal" term from the original model formula
formula.terminalEvent = formula.terminalEvent2,
jointGeneral = F,
data = data,
recurrentAG= !gapTimes,
hazard = "Weibull", RandDist = "LogN",
maxit = 100, print.times = F)
library(frailtypack)
library(frailtypack); library(gt); library(tidyverse)
knitr::opts_chunk$set(echo = FALSE,message = FALSE)
load(file = "../reduce_data/processed_data_coma_delirium_2mgonly.rdata")
df2 <- df2 %>% ungroup %>%
filter(study_arm!=3 & (apache > 0) & !is.na(apache))%>%
mutate(gap = tstop - tstart,
id = dense_rank(id),
treatment = 1*(study_arm==2),
age60 = 1*(age<60),
age70 = 1*(age<70),
age80 = 1*(age<80))
#table(df2$apache, useNA = "ifany")
#table(df2$age, useNA = "ifany")
table(df2$treatment, useNA = "ifany")
df2 %>% group_by(id) %>% summarise(apache = apache[1], age = age[1]) %>%
summarise(length(unique(id)),
mean(apache), mean(age),
sd(apache), sd(age),
cor(age, apache),
quantile(age,0.25),
quantile(age,0.5),
quantile(age,0.75),
mean(age<50), mean(age<60),mean(age<70), mean(age<80),
min(age), max(age))
#############################
# GAP Time Models (with/without initialization)
gap.model <-
multivPenal(formula = Surv(tstart, tstop, del) ~ treatment +
terminal(death) + terminal2(discharge) + cluster(id),
formula.terminalEvent = ~treatment,
formula.terminalEvent2= ~treatment,
data = df2,
gapTimes = T,
jointGeneral = F,
hazard = "Weibull",
maxit = 300,
initialize = T)
library(frailtypack)
library(frailtypack); library(gt); library(tidyverse)
knitr::opts_chunk$set(echo = FALSE,message = FALSE)
load(file = "../reduce_data/processed_data_coma_delirium_2mgonly.rdata")
df2 <- df2 %>% ungroup %>%
filter(study_arm!=3 & (apache > 0) & !is.na(apache))%>%
mutate(gap = tstop - tstart,
id = dense_rank(id),
treatment = 1*(study_arm==2),
age60 = 1*(age<60),
age70 = 1*(age<70),
age80 = 1*(age<80))
#table(df2$apache, useNA = "ifany")
#table(df2$age, useNA = "ifany")
table(df2$treatment, useNA = "ifany")
df2 %>% group_by(id) %>% summarise(apache = apache[1], age = age[1]) %>%
summarise(length(unique(id)),
mean(apache), mean(age),
sd(apache), sd(age),
cor(age, apache),
quantile(age,0.25),
quantile(age,0.5),
quantile(age,0.75),
mean(age<50), mean(age<60),mean(age<70), mean(age<80),
min(age), max(age))
#############################
# GAP Time Models (with/without initialization)
gap.model <-
multivPenal(formula = Surv(tstart, tstop, del) ~ treatment +
terminal(death) + terminal2(discharge) + cluster(id),
formula.terminalEvent = ~treatment,
formula.terminalEvent2= ~treatment,
data = df2,
gapTimes = T,
jointGeneral = F,
hazard = "Weibull",
maxit = 300,
initialize = T)
library(frailtypack)
library(frailtypack); library(gt); library(tidyverse)
knitr::opts_chunk$set(echo = FALSE,message = FALSE)
load(file = "../reduce_data/processed_data_coma_delirium_2mgonly.rdata")
df2 <- df2 %>% ungroup %>%
filter(study_arm!=3 & (apache > 0) & !is.na(apache))%>%
mutate(gap = tstop - tstart,
id = dense_rank(id),
treatment = 1*(study_arm==2),
age60 = 1*(age<60),
age70 = 1*(age<70),
age80 = 1*(age<80))
#table(df2$apache, useNA = "ifany")
#table(df2$age, useNA = "ifany")
table(df2$treatment, useNA = "ifany")
df2 %>% group_by(id) %>% summarise(apache = apache[1], age = age[1]) %>%
summarise(length(unique(id)),
mean(apache), mean(age),
sd(apache), sd(age),
cor(age, apache),
quantile(age,0.25),
quantile(age,0.5),
quantile(age,0.75),
mean(age<50), mean(age<60),mean(age<70), mean(age<80),
min(age), max(age))
#############################
# GAP Time Models (with/without initialization)
gap.model <-
multivPenal(formula = Surv(tstart, tstop, del) ~ treatment +
terminal(death) + terminal2(discharge) + cluster(id),
formula.terminalEvent = ~treatment,
formula.terminalEvent2= ~treatment,
data = df2,
gapTimes = T,
jointGeneral = F,
hazard = "Weibull",
maxit = 300,
initialize = T)
gap.model$summary.table
library(frailtypack)
devtools::document()
